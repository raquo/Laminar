<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Virtual DOM is a Hack · Laminar</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="First of all, I should say that I very much appreciate all the libraries mentioned here. But I do need to explain why I think Laminar&#x27;s approach is superior, so I will be making comparisons from my point of view. A lot of this is subjective. The problem at hand is too complicated for there to be the one unquestionable solution."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Virtual DOM is a Hack · Laminar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://laminar.dev/"/><meta property="og:description" content="First of all, I should say that I very much appreciate all the libraries mentioned here. But I do need to explain why I think Laminar&#x27;s approach is superior, so I will be making comparisons from my point of view. A lot of this is subjective. The problem at hand is too complicated for there to be the one unquestionable solution."/><meta property="og:image" content="https://laminar.dev/img/brand/laminar-opengraph-opt.png"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="alternate" type="application/atom+xml" href="https://laminar.dev/blog/atom.xml" title="Laminar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://laminar.dev/blog/feed.xml" title="Laminar Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Laminar</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/documentation" target="_self">Docs</a></li><li class=""><a href="https://demo.laminar.dev" target="_self">Examples</a></li><li class=""><a href="/resources" target="_self">Resources</a></li><li class=""><a href="/blog/" target="_self">News</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Virtual DOM is a Hack</h1></header><article><div><span><p>First of all, I should say that I very much appreciate all the libraries mentioned here. But I do need to explain why I think Laminar's approach is superior, so I will be making comparisons from my point of view. A lot of this is subjective. The problem at hand is too complicated for there to be the one unquestionable solution.</p>
<h2><a class="anchor" aria-hidden="true" id="virtual-dom-vs-frp"></a><a href="#virtual-dom-vs-frp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Virtual DOM vs FRP</h2>
<p>Facebook needed a performant, reactive way to build web applications, and so React.js popularized virtual DOM because (in part) type-safe functional reactive programming was not a viable option for their target audience.</p>
<p>Despite its wide popularity, there is nothing special about virtual DOM, it is merely a solution to a specific problem, and not a great one – it's <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">pretty</a> <a href="https://reactjs.org/docs/reconciliation.html">complicated</a>, and its performance is limited by the often-significant amount of work the framework needs to perform when diffing virtual element trees.</p>
<p>All of that diffing machinery is required because virtual DOM elements / subtrees have no continuity – they're ephemeral. Every time a React component's state or props change, it will re-run its <code>render</code> method (which often means doing the same recursively for its child components) to generate a new virtual subtree that is completely separate from the previous subtree generated by this same component.</p>
<p>All of this only gets worse when you put wrappers around native javascript libraries. ScalaJS-React for example is not just a bunch of thin <code>@js.native</code> interfaces, it brings in its own concepts and runtime code.</p>
<p>Laminar on the other hand does not use virtual DOM diffing. Instead, it uses event streams and reactive state variables for <strong>precise DOM updates</strong>. So when your Laminar code says it needs an element's color property to be updated, that's exactly what will happen, immediately, directly, and nothing else. For comparison, with virtual DOM a bunch of render methods would have been run, new virtual elements would have been created, the framework would have generated the diff of the new and old subtrees of virtual elements, and finally translated this diff into an actual one-line DOM update that we actually care about.</p>
<p>Laminar does maintain its own tree of <code>ReactiveElement</code>-s, but it's only used to track parent-child relationships between elements, not their attributes and properties. We never need to diff virtual elements. Also, unlike ephemeral virtual DOM elements, the lifespan of Laminar's reactive elements matches the lifespan of corresponding real DOM elements, so you get stable references that you can easily work with.</p>
<p>I personally see virtual DOM as a very elaborate way to avoid using actual reactive data structures like streams. And virtual DOM is not useful even if you do use FRP. Early versions of Laminar did actually use virtual DOM (Snabbdom), but I ran away from that when I realized how counter-productive the combination of those paradigms is, both to simplicity and performance.</p>
<h2><a class="anchor" aria-hidden="true" id="virtual-dom-_with_-frp"></a><a href="#virtual-dom-_with_-frp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Virtual DOM <em>with</em> FRP</h2>
<blockquote>
<p>I've provided a more in depth explanation for why Virtual DOM and FRP don't mix in this blog post: <a href="https://dev.to/raquo/my-four-year-quest-for-perfect-scala-js-ui-development-b9a">My Four Year Quest For Perfect Scala.js UI Development</a></p>
</blockquote>
<p>Some other libraries like Outwatch (or Cycle.js in the JS world) use both FRP and virtual DOM as a way to achieve complete functional purity. To me this concept is largely lost for frontend development. I don't think the effort, conceptual complexity, and performance penalties of wrapping everything in effect types and virtual elements is worth the marginal safety that some of this could provide. The entire frontend application is <em>supposed</em> to be a collection of DOM and network IO effects, there is barely anything else to it. Like any other technique, pure functional programming is only good for the benefits that it provides, and I don't think it provides a net benefit in frontend development when you consider all the compromises you have to make for it, and all of their effects (ha). This is, of course, a matter of preference, and so both Outwatch and Laminar exist.</p>
<p><em>A bit more on Cycle.js <a href="https://gitter.im/Laminar_/Lobby?at=5b749e5c5b07ae730ac330c4">in our Gitter</a>.</em></p>
<p>As mentioned above, I did previously use virtual DOM in Laminar, and this experience convinced me that reactive UI development is much, much simpler with FRP alone, without virtual DOM.</p>
<p>Outwatch and Laminar are quite similar cosmetically – their arrows notation was just too good not to steal – but they're vastly different under the hood. If you're curious, you can dive into sources to compare how a simple expression such as <code>div(widthAttr &lt;-- widthStream)</code> is handled. See what exactly happens when a new event is sent to <code>widthStream</code>. Ignore the internals of the streaming libraries (RxJS and Airstream) which call <code>Observer.onNext</code> (as they'll be quite similar), but do look at the rest of the code path otherwise. Here it is for Laminar v0.8:</p>
<ol>
<li>Go to definition of this <code>&lt;--</code> method, it's in <code>HtmlAttr</code> because that's what <code>widthAttr</code> is:</li>
</ol>
<pre><code class="hljs css language-scala">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&lt;--</span></span>(values: <span class="hljs-type">Observable</span>[<span class="hljs-type">V</span>]): <span class="hljs-type">Binder</span>[<span class="hljs-type">HtmlElement</span>] = {
    <span class="hljs-type">Binder</span> { element =&gt;
      <span class="hljs-type">ReactiveElement</span>.bindFn(element, values) { value =&gt;
        <span class="hljs-type">DomApi</span>.setHtmlAttribute(element, <span class="hljs-keyword">this</span>, value)
      }
    }
  }
</code></pre>
<ol start="2">
<li>Putting our reactive boilerplate aside for a moment, you see that we call <code>DomApi.setHtmlAttribute</code> when <code>widthStream</code> (i.e. <code>values</code> here) emits a new <code>value</code>. Going to its definition we see:</li>
</ol>
<pre><code class="hljs css language-scala">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setHtmlAttribute</span></span>[<span class="hljs-type">V</span>](element: <span class="hljs-type">ReactiveHtmlElement</span>.<span class="hljs-type">Base</span>, attr: <span class="hljs-type">HtmlAttr</span>[<span class="hljs-type">V</span>], value: <span class="hljs-type">V</span>): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">val</span> domValue = attr.codec.encode(value)
    <span class="hljs-keyword">if</span> (domValue == <span class="hljs-literal">null</span>) { <span class="hljs-comment">// End users should use `removeAttribute` instead. This is to support boolean attributes.</span>
      removeHtmlAttribute(element, attr)
    } <span class="hljs-keyword">else</span> {
      element.ref.setAttribute(attr.name, domValue.toString)
    }
  }
</code></pre>
<p>That <code>element.ref.setAttribute(...)</code> is a call to native Javascript DOM API. There is no library code behind it. You can see for yourself how the same code path goes in Outwatch. It's quite a bit more involved, especially if you look into Snabbdom. I won't even ask you to try this with React.</p>
<p>I guess I skipped over how <code>Binder</code> works. On a high level, when the element is mounted, the Binder subscribes the provided callback to fire every time the <code>values</code> observable emits a new value, and kills that subscription when the element is unmounted. You can of course follow the <code>Binder.apply</code> method and <code>ReactiveElement.bindFn</code> to see how this works, but that's going very deep into the innards our reactive system, and you'll want to read our docs. We do explain how everything works in great detail.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#virtual-dom-vs-frp">Virtual DOM vs FRP</a></li><li><a href="#virtual-dom-_with_-frp">Virtual DOM <em>with</em> FRP</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div class="community-column"><h5>Community</h5><a href="https://discord.gg/JTrUxhq7sj">Discord chat</a><a href="https://github.com/sponsors/raquo">Sponsor the project</a></div><div class="github-column"><h5>Github</h5><p><a class="github-button" data-icon="octicon" href="https://github.com/raquo/Laminar">Laminar</a></p><p><a class="github-button" data-icon="octicon" href="https://github.com/raquo/Airstream">Airstream</a></p><p><a class="github-button" data-icon="octicon" href="https://github.com/raquo/Waypoint">Waypoint</a></p><p><a class="github-button" data-icon="octicon" href="https://github.com/raquo/scala-dom-types">Scala DOM Types</a></p><p><a class="github-button" data-icon="octicon" href="https://github.com/raquo/laminar-full-stack-demo">Laminar Demo</a></p><p><a class="github-button" href="https://github.com/raquo/Laminar" data-icon="octicon-star" data-count-href="/raquo/Laminar/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></p></div></section><section class="copyright">Copyright © 2025 Nikita Gazarov</section></footer></div></body></html>